// Test if a new solution can be added for contract - SolnSquareVerifier

// Test if an ERC721 token can be minted for contract - SolnSquareVerifier
// define a variable to import the <Verifier> or <renamedVerifier> solidity contract generated by Zokrates
const SolnSquareVerifier = artifacts.require('SolnSquareVerifier');
const proofJson = require('../proof.json')[0];

contract('TestSolnSquareVerifier', accounts => {

    const account_one = accounts[0];
    const account_two = accounts[1];

    describe('solution', function () {
        beforeEach(async function () { 
            this.contract = await SolnSquareVerifier.new({from: account_one});
        })

        it('should add a new solution', async function () {
            const old_solutions = await this.contract.solutions.call();
            await this.contract.addSolution(account_one, proofJson.proof.a, proofJson.proof.b, proofJson.proof.c, proofJson.inputs, {from: account_one});
            const new_solutions = await this.contract.solutions.call();
            assert.equal(parseInt(old_solutions) + 1, parseInt(new_solutions), 'solution not be added');
        })

        it('should be able to mint a token', async function () {
            await this.contract.addSolution(account_one, proofJson.proof.a, proofJson.proof.b, proofJson.proof.c, proofJson.inputs, {from: account_one});
            const old_balance = await this.contract.balanceOf.call(account_one);
            await this.contract.mint(account_one, proofJson.proof.a, proofJson.proof.b, proofJson.proof.c, proofJson.inputs, {from: account_one});
            const new_balance = await this.contract.balanceOf.call(account_one);
            assert.equal(parseInt(old_balance) + 1, parseInt(new_balance), 'token not be added');

        })
    });
})